/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VariableUse
import java.util.Map
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.Expression
import dk.sdu.mmmi.mdsd.math.Method
import dk.sdu.mmmi.mdsd.math.Parenthesis
import dk.sdu.mmmi.mdsd.math.VarBinding
import dk.sdu.mmmi.mdsd.math.LetBinding
import java.util.HashMap
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.Binding

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = resource.allContents.filter(MathExp).next
		fsa.generateFile("math_expression/" + program.name + ".java", program.compile)
	}
		
	def compile(MathExp program){

		'''
		package math_expression;
		
		public class «program.name» {
			«FOR varBinding: program.variables»
			public int «varBinding.name»;
			«ENDFOR»
			
			public void compute() {
				«FOR varBinding: program.variables»
				«varBinding.name» = «varBinding.expression.computeExpression»;
				«ENDFOR»
			}
			
			«IF program.externals.size > 0»
			private External external;
			  
			public «program.name»(External external) {
				this.external = external;
			}
			public interface External {
				«FOR func : program.externals»
					int «func.name»(«IF func.args.size == 1»int n«ENDIF»«IF func.args.size == 2»int n, int m«ENDIF»);
				«ENDFOR»
			}
			«ENDIF»
		}
		'''
	}
	
	def static dispatch String computeExpression(Expression exp) {
		switch exp {
			MathNumber: exp.value.toString
			Plus: exp.left.computeExpression + ' + ' + exp.right.computeExpression
			Minus: exp.left.computeExpression + ' - ' + exp.right.computeExpression
			Mult: exp.left.computeExpression + ' * ' + exp.right.computeExpression
			Div: exp.left.computeExpression + ' / ' + exp.right.computeExpression
			Parenthesis: '(' + exp.exp.computeExpression + ')'
			LetBinding: exp.body.computeExpression
			VariableUse: '(' + exp.ref.computeBinding + ')'
			Method: '''this.external.'''+ exp.ref.name + '''(«FOR x : exp.exps SEPARATOR ', '» «x.computeExpression» «ENDFOR»)'''
		}
	}
	

	def static dispatch String computeBinding(Binding binding) {
		switch binding {
			VarBinding: binding.name
			LetBinding: binding.binding.computeExpression
		}
	}
	
}
