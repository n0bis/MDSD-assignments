 /*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.Number
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.MulOrDiv
import dk.sdu.mmmi.mdsd.math.AbstractElement
import dk.sdu.mmmi.mdsd.math.VariableUse
import com.google.inject.Inject
import org.eclipse.xtext.util.IResourceScopeCache
import dk.sdu.mmmi.mdsd.math.Expression
import dk.sdu.mmmi.mdsd.math.Variable
import dk.sdu.mmmi.mdsd.math.LetExpression
import dk.sdu.mmmi.mdsd.math.Atomic
import dk.sdu.mmmi.mdsd.math.MathExp

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {
	
	static Map<String, Integer> variables = new HashMap();
	static Map<String, Integer> letvariables = new HashMap();
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.allContents.filter(MathExp).next
		val result = model.compute
		result.displayPanel
	}
	
	def static compute(MathExp model) {
		for (variable : model.elements) {
			variables.put(variable.name, variable.expression.computeExp)
			letvariables.clear()
		}
		return variables
	}
	
	def static int computeExp(Expression e) {
		switch e {
			MulOrDiv: {
				val left = e.left.computeExp as Integer
				val right = e.right.computeExp as Integer
				if (e.op == '*')
					left * right
				else
					left / right
			}
			Minus:
				(e.left.computeExp as Integer) - (e.right.computeExp as Integer)
			Plus: {
				(e.left.computeExp as Integer) + (e.right.computeExp as Integer)
			}
			LetExpression: {
				letvariables.put(e.name, e.variable.computeExp)
				//variables.put(e.name, e.variable.computeExp)
				e.expression.computeExp
			}
			Atomic: {
				switch e {
					VariableUse: {
						if(letvariables.get(e.variableUse.name) !== null)
							letvariables.get(e.variableUse.name)
						else
							variables.get(e.variableUse.name)
					}
					Number: e.value
				}
			}
			default: (e as Variable).expression.computeExp
		}
	}

	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}


}
